<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>js 高级技巧 | andy chen 的博客</title>
    <meta name="description" content="每天进步一点点">
    
    
    <link rel="preload" href="/new-blog/assets/css/0.styles.f9ffd470.css" as="style"><link rel="preload" href="/new-blog/assets/js/app.9bb2b09b.js" as="script"><link rel="preload" href="/new-blog/assets/js/15.d077ddae.js" as="script"><link rel="prefetch" href="/new-blog/assets/js/10.5d17d009.js"><link rel="prefetch" href="/new-blog/assets/js/11.471c3d76.js"><link rel="prefetch" href="/new-blog/assets/js/12.958f900b.js"><link rel="prefetch" href="/new-blog/assets/js/13.b6e418ab.js"><link rel="prefetch" href="/new-blog/assets/js/14.7635c454.js"><link rel="prefetch" href="/new-blog/assets/js/16.99208fe9.js"><link rel="prefetch" href="/new-blog/assets/js/17.a7099edc.js"><link rel="prefetch" href="/new-blog/assets/js/18.be85ec58.js"><link rel="prefetch" href="/new-blog/assets/js/19.292ffcfa.js"><link rel="prefetch" href="/new-blog/assets/js/2.4849f1b1.js"><link rel="prefetch" href="/new-blog/assets/js/20.e656d17f.js"><link rel="prefetch" href="/new-blog/assets/js/21.2bb2852b.js"><link rel="prefetch" href="/new-blog/assets/js/22.7aacb0e1.js"><link rel="prefetch" href="/new-blog/assets/js/23.cca83e39.js"><link rel="prefetch" href="/new-blog/assets/js/24.61ec2cb1.js"><link rel="prefetch" href="/new-blog/assets/js/25.4a0066c6.js"><link rel="prefetch" href="/new-blog/assets/js/26.43a68f8c.js"><link rel="prefetch" href="/new-blog/assets/js/27.7af785b9.js"><link rel="prefetch" href="/new-blog/assets/js/28.c8bf4268.js"><link rel="prefetch" href="/new-blog/assets/js/29.1da88be3.js"><link rel="prefetch" href="/new-blog/assets/js/3.d5171b82.js"><link rel="prefetch" href="/new-blog/assets/js/30.dc37ceeb.js"><link rel="prefetch" href="/new-blog/assets/js/31.07d64fea.js"><link rel="prefetch" href="/new-blog/assets/js/32.f1f27f3f.js"><link rel="prefetch" href="/new-blog/assets/js/33.53107a59.js"><link rel="prefetch" href="/new-blog/assets/js/34.aad91bd6.js"><link rel="prefetch" href="/new-blog/assets/js/35.43a6badc.js"><link rel="prefetch" href="/new-blog/assets/js/36.a44d4920.js"><link rel="prefetch" href="/new-blog/assets/js/37.d195a0fb.js"><link rel="prefetch" href="/new-blog/assets/js/38.21caad6b.js"><link rel="prefetch" href="/new-blog/assets/js/39.b8a10b24.js"><link rel="prefetch" href="/new-blog/assets/js/4.3d3c2d5d.js"><link rel="prefetch" href="/new-blog/assets/js/40.cb657f79.js"><link rel="prefetch" href="/new-blog/assets/js/41.158b72ee.js"><link rel="prefetch" href="/new-blog/assets/js/42.886b8ae4.js"><link rel="prefetch" href="/new-blog/assets/js/5.c0c38c2a.js"><link rel="prefetch" href="/new-blog/assets/js/6.51541069.js"><link rel="prefetch" href="/new-blog/assets/js/7.e1ff8d6c.js"><link rel="prefetch" href="/new-blog/assets/js/8.7bc83ad3.js"><link rel="prefetch" href="/new-blog/assets/js/9.55cb94eb.js">
    <link rel="stylesheet" href="/new-blog/assets/css/0.styles.f9ffd470.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/new-blog/" class="home-link router-link-active"><!----> <span class="site-name">andy chen 的博客</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">更多</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://chen4342024.github.io/code-snippet/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  代码片段收集
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="https://github.com/chen4342024" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">更多</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://chen4342024.github.io/code-snippet/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  代码片段收集
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="https://github.com/chen4342024" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><div class="sidebar-group first"><p class="sidebar-heading"><span>JS 相关</span> <!----></p> <ul class="sidebar-group-items"><li><a href="/new-blog/js/promise.html" class="sidebar-link">Promise 简单实现</a></li><li><a href="/new-blog/js/compressImage.html" class="sidebar-link">利用 canvas 压缩图片</a></li><li><a href="/new-blog/js/task.html" class="sidebar-link">js 任务</a></li></ul></div></li><li><div class="sidebar-group"><p class="sidebar-heading open"><span>JS高级编程设计</span> <!----></p> <ul class="sidebar-group-items"><li><a href="/new-blog/js/js-book/advanced.html" class="active sidebar-link">js 高级技巧</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/new-blog/js/js-book/advanced.html#高级函数" class="sidebar-link">高级函数</a></li><li class="sidebar-sub-header"><a href="/new-blog/js/js-book/advanced.html#防篡改对象" class="sidebar-link">防篡改对象</a></li><li class="sidebar-sub-header"><a href="/new-blog/js/js-book/advanced.html#高级定时器" class="sidebar-link">高级定时器</a></li><li class="sidebar-sub-header"><a href="/new-blog/js/js-book/advanced.html#数组分块" class="sidebar-link">数组分块</a></li><li class="sidebar-sub-header"><a href="/new-blog/js/js-book/advanced.html#函数节流" class="sidebar-link">函数节流</a></li><li class="sidebar-sub-header"><a href="/new-blog/js/js-book/advanced.html#自定义事件" class="sidebar-link">自定义事件</a></li><li class="sidebar-sub-header"><a href="/new-blog/js/js-book/advanced.html#小结" class="sidebar-link">小结</a></li></ul></li><li><a href="/new-blog/js/js-book/bestPractice.html" class="sidebar-link">js 最佳实践</a></li><li><a href="/new-blog/js/js-book/canvas.html" class="sidebar-link">使用 canvas 绘图</a></li><li><a href="/new-blog/js/js-book/context.html" class="sidebar-link">变量、作用域和内存问题 context</a></li><li><a href="/new-blog/js/js-book/env.html" class="sidebar-link">客户端检测</a></li><li><a href="/new-blog/js/js-book/event.html" class="sidebar-link">事件</a></li><li><a href="/new-blog/js/js-book/oop.html" class="sidebar-link">面向对象的程序设计</a></li><li><a href="/new-blog/js/js-book/referenceType.html" class="sidebar-link">引用类型</a></li></ul></div></li><li><div class="sidebar-group"><p class="sidebar-heading"><span>underscore源码解析</span> <!----></p> <ul class="sidebar-group-items"><li><a href="/new-blog/js/underscore/restArgs.html" class="sidebar-link">不定参数</a></li><li><a href="/new-blog/js/underscore/tip.html" class="sidebar-link">小技巧</a></li></ul></div></li><li><div class="sidebar-group"><p class="sidebar-heading"><span>snabbdom源码解析</span> <!----></p> <ul class="sidebar-group-items"><li><a href="/new-blog/js/vue/snabbdom/prepare.html" class="sidebar-link">准备工作</a></li><li><a href="/new-blog/js/vue/snabbdom/h.html" class="sidebar-link">h 函数</a></li><li><a href="/new-blog/js/vue/snabbdom/vnode.html" class="sidebar-link">vnode 对象</a></li><li><a href="/new-blog/js/vue/snabbdom/patch.html" class="sidebar-link">patch 方法</a></li><li><a href="/new-blog/js/vue/snabbdom/hooks.html" class="sidebar-link">钩子</a></li><li><a href="/new-blog/js/vue/snabbdom/modules.html" class="sidebar-link">模块</a></li><li><a href="/new-blog/js/vue/snabbdom/event.html" class="sidebar-link">事件处理</a></li><li><a href="/new-blog/js/vue/snabbdom/util.html" class="sidebar-link">工具</a></li></ul></div></li><li><div class="sidebar-group"><p class="sidebar-heading"><span>vue-router源码解析</span> <!----></p> <ul class="sidebar-group-items"><li><a href="/new-blog/js/vue/vue-router/prepare.html" class="sidebar-link">准备工作</a></li><li><a href="/new-blog/js/vue/vue-router/plugin.html" class="sidebar-link">vue 插件方式的实现</a></li><li><a href="/new-blog/js/vue/vue-router/mode.html" class="sidebar-link">路由模式及降级处理</a></li><li><a href="/new-blog/js/vue/vue-router/match.html" class="sidebar-link">路由匹配规则</a></li><li><a href="/new-blog/js/vue/vue-router/navEvent.html" class="sidebar-link">导航守卫</a></li><li><a href="/new-blog/js/vue/vue-router/component.html" class="sidebar-link">组件 route-view 、 route-link</a></li><li><a href="/new-blog/js/vue/vue-router/scroll.html" class="sidebar-link">滚动处理</a></li><li><a href="/new-blog/js/vue/vue-router/async.html" class="sidebar-link">路由懒加载 、 异步加载组件</a></li></ul></div></li><li><div class="sidebar-group"><p class="sidebar-heading"><span>算法</span> <!----></p> <ul class="sidebar-group-items"><li><a href="/new-blog/js/algorithm/baseSort.html" class="sidebar-link">基本排序算法</a></li></ul></div></li><li><div class="sidebar-group"><p class="sidebar-heading"><span>其他</span> <!----></p> <ul class="sidebar-group-items"><li><a href="/new-blog/other/git.html" class="sidebar-link">git 操作</a></li><li><a href="/new-blog/other/rem.html" class="sidebar-link">REM 实现移动端自适应</a></li><li><a href="/new-blog/other/weixinDebug.html" class="sidebar-link">使用 Fiddler 调试微信 js sdk</a></li><li><a href="/new-blog/other/highQualityCode.html" class="sidebar-link">编写可维护的代码</a></li><li><a href="/new-blog/other/cache.html" class="sidebar-link">缓存</a></li><li><a href="/new-blog/other/http.html" class="sidebar-link">http 与 https</a></li></ul></div></li><li><a href="/new-blog/aboutMe/" class="sidebar-link">关于作者</a></li></ul> </div> <div class="page"> <div class="content"><h1 id="js-高级技巧"><a href="#js-高级技巧" aria-hidden="true" class="header-anchor">#</a> js 高级技巧</h1> <h2 id="高级函数"><a href="#高级函数" aria-hidden="true" class="header-anchor">#</a> 高级函数</h2> <h3 id="安全的类型检测"><a href="#安全的类型检测" aria-hidden="true" class="header-anchor">#</a> 安全的类型检测</h3> <ul><li>js 内置的类型检测并非完全可靠，typeof 操作符难以判断某个值是否为函数</li> <li>instanceof 在多个 frame 的情况下，会出现问题。
例如：<code>var isArray = value instance of Array ;</code>
会由于存在多个 window，而 value 与 Array 不属于同个 window 的情况而导致出错</li></ul> <p>对于这样的问题，最好的解决方法是通过调用 Object 的 toString 方法，例如：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">isArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> Object<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>toString<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">'[object Array]'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><blockquote><p>注意，这个技巧前提是 Object.prototype.toString 方法未被修改过</p></blockquote> <h3 id="作用域安全的构造函数"><a href="#作用域安全的构造函数" aria-hidden="true" class="header-anchor">#</a> 作用域安全的构造函数</h3> <p>调用构造函数的时候，如果忘记写 new 的话，构造函数中对 this 的赋值，则可能会赋值到 window 上成为全局变量，导致其他错误。
可以在构造函数增加判断来避免这种错误,如下：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token keyword">instanceof</span> <span class="token class-name">Person</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="惰性载入函数"><a href="#惰性载入函数" aria-hidden="true" class="header-anchor">#</a> 惰性载入函数</h3> <p>在程序中 ，类似对浏览器的检测等，进行一次检测过后，只要在当前环境下，其检测结果都不会改变。所以，我们的函数中 if 语句只需要判断一次就可以了，而不需要每次都执行。
对这种情况的解决方案便称为惰性载入。
惰性载入表示函数执行的分支仅会发生一次。</p> <h4 id="惰性载入两种实现方法："><a href="#惰性载入两种实现方法：" aria-hidden="true" class="header-anchor">#</a> 惰性载入两种实现方法：</h4> <ul><li>替换真正执行的方法，伪代码如下：</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>someCheck<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function-variable function">foo</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">doSomeThing</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token function-variable function">foo</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">doAnotherSomeThing</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>声明函数时就指定适当的函数。通过匿名自执行函数</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">var</span> foo <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>someCheck<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">doSomeThing</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">doAnotherSomeThing</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>这样，在代码首次载入的时候，就已经得到对应的值了</p> <h3 id="函数绑定"><a href="#函数绑定" aria-hidden="true" class="header-anchor">#</a> 函数绑定</h3> <p>先看一个例子：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">var</span> handler <span class="token operator">=</span> <span class="token punctuation">{</span>
    message<span class="token punctuation">:</span> <span class="token string">'handler message'</span><span class="token punctuation">,</span>
    handlerClick<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">//用于将某个函数绑定到指定环境</span>
<span class="token keyword">var</span> <span class="token function-variable function">bind</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span> context<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        fn<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> nomalBtn <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'nomalBtn'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> bindBtn <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'bindBtn'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

nomalBtn<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> handler<span class="token punctuation">.</span>handlerClick<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//点击时候会打印 undefined</span>
bindBtn<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> <span class="token function">bind</span><span class="token punctuation">(</span>handler<span class="token punctuation">.</span>handlerClick<span class="token punctuation">,</span> handler<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//点击按钮会打印 handler.message的值</span>
</code></pre></div><p>在上面的例子中，我们需要对象中的方法作为事件处理程序。但是，当事件触发时，this 的指向却不是 handler 而是按钮本身。
解决方法可以使用匿名函数，但是，过多的匿名函数会令代码变的难于理解与调试，因此，推荐使用 bind 方法。</p> <blockquote><p>ES5 为函数定义了一个原生的 bind 方法，也就是说，你不必自己实现 bind 方法，只需要直接在函数上调用即可<code>handler.handlerClick.bind(handler) ;</code></p></blockquote> <h3 id="函数科里化"><a href="#函数科里化" aria-hidden="true" class="header-anchor">#</a> 函数科里化</h3> <p>函数科里化是用于创建已经设置好一个或多个参数的函数。缩小了函数的适用范围，但提高函数的适性。
例如：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">//普通的add版本</span>
<span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span>num1<span class="token punctuation">,</span> num2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> num1 <span class="token operator">+</span> num2<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//第一个参数为5的add版本</span>
<span class="token keyword">function</span> <span class="token function">curriedAdd5</span><span class="token punctuation">(</span>num2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> num2<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>上面只是一个展示柯里化概念的例子。创建柯里化函数有一个通用方式：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">curry</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span> context<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//截取调用curry时候，除了fn,context,之后的所有参数</span>
    <span class="token keyword">var</span> args <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span>slice<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arguments<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">//获取调用fn的所有参数</span>
        <span class="token keyword">var</span> totalArgs <span class="token operator">=</span> args<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span>slice<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> fn<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> totalArgs<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这样，上面的例子中 curriedAdd5 可以用另一个方法来创建 <code>var curriedAdd5 = curry(add, null, 5)</code></p> <p>javascript 中的柯里化函数和 bind 函数提供了强大的动态函数创建功能，但是两者都不应该滥用，因为每个函数都带来额外的开销</p> <h2 id="防篡改对象"><a href="#防篡改对象" aria-hidden="true" class="header-anchor">#</a> 防篡改对象</h2> <h3 id="不可扩展对象"><a href="#不可扩展对象" aria-hidden="true" class="header-anchor">#</a> 不可扩展对象</h3> <p>不可扩展表示不能给该对象添加新属性和新方法，非严格情况下会静默失败，严格模式下会报错
主要有两个方法：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>Object<span class="token punctuation">.</span><span class="token function">preventExtensions</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//将对象定义为不可扩展的</span>
Object<span class="token punctuation">.</span><span class="token function">isExtensible</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 判读对象是否可以扩展</span>
</code></pre></div><h3 id="密封的对象"><a href="#密封的对象" aria-hidden="true" class="header-anchor">#</a> 密封的对象</h3> <p>密封的对象表示不可扩展，且成员 Configurable 特性为 false，即不能删除属性和方法，也不能修改属性的特性
主要有两个方法：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>Object<span class="token punctuation">.</span><span class="token function">seal</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//将对象定义为密封的</span>
Object<span class="token punctuation">.</span><span class="token function">isSealed</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 判读对象是否密封</span>
</code></pre></div><h3 id="冻结的对象"><a href="#冻结的对象" aria-hidden="true" class="header-anchor">#</a> 冻结的对象</h3> <p>冻结的对象是最严格的反篡改级别。即不可扩展，又是密封的，且数据属性的 writable 特性为 false。如果定义了[[set]]函数,访问器属性还是可写的
主要有两个方法：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>Object<span class="token punctuation">.</span><span class="token function">freeze</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//将对象定义冻结对象</span>
Object<span class="token punctuation">.</span><span class="token function">isFrozen</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 判读对象被冻结</span>
</code></pre></div><p>对于 js 库的作者而言，冻结对象很有用，因为 js 库最怕有人意外修改了库中的核心对象。</p> <h2 id="高级定时器"><a href="#高级定时器" aria-hidden="true" class="header-anchor">#</a> 高级定时器</h2> <h3 id="重复的定时器"><a href="#重复的定时器" aria-hidden="true" class="header-anchor">#</a> 重复的定时器</h3> <p>setInterval ： 创建的定时器确保了定时器代码规则的插入队列中。
但是会有两个问题：</p> <ol><li>某些间隔会被跳过</li> <li>多个定时器的代码执行之间的间隔可能比预期的小</li></ol> <p>为了避免这两个问题，可以用如下模式使用链式 setTimeout。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span>arguments<span class="token punctuation">.</span>callee<span class="token punctuation">,</span> intervalTime<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> intervalTime<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>这样可以确保不会有缺失的间隔，而且之间的间隔比预期的大</p> <h2 id="数组分块"><a href="#数组分块" aria-hidden="true" class="header-anchor">#</a> 数组分块</h2> <p>由于 js 是单线程的，有时候一个耗时的操作会阻塞线程，导致这段时间用户无法与界面交互。
如果是某个循环比较耗时，并且该循环并不必须同步完成，就可以使用**<em>数组分块</em>**的技术，小块小块的处理数组，给主线程有空闲的机会，就可以不影响用户的操作。
实现数组分块非常简单：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">chunk</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> process<span class="token punctuation">,</span> context<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">var</span> item <span class="token operator">=</span> array<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        process<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> item<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>array<span class="token punctuation">.</span>length <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">setTimeout</span><span class="token punctuation">(</span>arguments<span class="token punctuation">.</span>callee<span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>使用的时候直接将要分块的数组以及处理程序作为参数即可</p> <blockquote><p>一旦某个函数需要花 50ms 以上的时间完成，就可以考虑能否分隔成多个小任务来完成</p></blockquote> <h2 id="函数节流"><a href="#函数节流" aria-hidden="true" class="header-anchor">#</a> 函数节流</h2> <p>浏览器中，某些计算和处理要比其他的昂贵的多。如果在触发频率很高的事件中去执行这些操作，有可能会导致浏览器第崩溃。函数节流就是为了解决这个问题
函数节流背后的思想是指，某些代码不可以在没有间断的情况下重复执行。第一次调用函数，创建一个定时器，在指定的时间间隔之后运行代码。当第二次调用函数时，清除前一次的定时器，并设置另一个。这样只有在执行函数的请求停止了之后才执行。</p> <h2 id="自定义事件"><a href="#自定义事件" aria-hidden="true" class="header-anchor">#</a> 自定义事件</h2> <p>观察者模式</p> <p style="color:red">（尚未详细了解）</p> <h2 id="小结"><a href="#小结" aria-hidden="true" class="header-anchor">#</a> 小结</h2> <p>js 中的函数非常强大，因为它们是第一类对象。使用闭包和函数环境切换，还可以有很多函数的强大方法。
善于使用高级函数来实现更好的功能。
善于使用观察者模式来使不同部分的代码之间解耦，让维护更容易</p></div> <div class="page-edit"><!----> <div class="last-updated"><span class="prefix">上次更新: </span> <span class="time">11/25/2018, 4:13:43 PM</span></div></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/new-blog/js/task.html" class="prev">
          js 任务
        </a></span> <span class="next"><a href="/new-blog/js/js-book/bestPractice.html">
          js 最佳实践
        </a>
        →
      </span></p></div> </div> <!----></div></div>
    <script src="/new-blog/assets/js/15.d077ddae.js" defer></script><script src="/new-blog/assets/js/app.9bb2b09b.js" defer></script>
  </body>
</html>
